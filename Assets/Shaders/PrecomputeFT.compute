#define _PI 3.14159265358979323846
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

Texture2D<float4> _RealMap;
Texture2D<float4> _ImaginaryMap;
RWTexture2D<float4> Result;

SamplerState SamplerLinearClamp;

float _Time;
float _LocalAccel;
half4 _BaseColor;
float _Lx;
float _Lz;
int _N;
int _M;
vector _WindInformation;
vector _LightDirection;
float _l;
float _TimeRepeat;
float _PhaseMult;

//----- HELPER FUNCTIONS -----
float2 complex_add(float2 c1, float2 c2)
{
    return c1 + c2;
}

float2 complex_sub(float2 c1, float2 c2)
{
    return complex_add(c1, -c2);
}

float2 complex_conjugate(float2 c)
{
    return float2(c.x, -c.y);
}

float2 complex_mult(float2 c1, float2 c2)
{
    return float2(c1.x * c2.x - c1.y * c2.y, c1.x * c2.y + c1.y * c2.x);
}

float2 complex_exp(float theta)
{
    return float2(cos(theta), sin(theta));
}

float2 get_uv(int n, int m)
{
    return float2(n, m) / float2(_N, _M);
}

int wrap_index(int i, int size)
{
    return (i + size) % size;
}

// ----- FT Functions -----

float calculate_k(int coord, int size, float length)
{
    return (2 * _PI * coord - _PI * size) / length;
}

float omega(int n_prime, int m_prime) 
{
    float w_0 = 2.0f * _PI / _TimeRepeat;
    float k_x = calculate_k(n_prime, _N, _Lx);
    float k_z = calculate_k(m_prime, _M, _Lz);
    return int(sqrt(_LocalAccel * sqrt(k_x * k_x + k_z * k_z)) / w_0) * w_0;
}

float phillips(int n_prime, int m_prime)
{
    float2 w_hat = normalize(_WindInformation.xy);
    float2 k_hat = float2(calculate_k(n_prime, _N, _Lx), calculate_k(m_prime, _M, _Lz));
    float k = length(k_hat);
    if (length(k_hat) <= _l)
        return 0;
    float V = _WindInformation.z;
    float A = _WindInformation.w;
    float L = (V * V) / _LocalAccel;
    float numerator = exp(-1 / pow((k * L), 2));
    float cos_factor = pow(dot(k_hat, w_hat), 2);
    return A * (numerator / pow(k, 4)) * cos_factor * exp(-(k * k * _l * _l));
}

float2 basis_dft(int n_prime, int m_prime)
{
    int2 coord = int2(n_prime, m_prime);
    float real_sample = _RealMap.Load(int3(coord, 0)).r;
    float imaginary_sample = _ImaginaryMap.Load(int3(coord, 0)).r;

    return (1 / sqrt(2.0)) * float2(real_sample, imaginary_sample) * sqrt(phillips(n_prime, m_prime));
}

float2 dft(int n_prime, int m_prime, float time)
{
    int n_wrapped = wrap_index(n_prime, _N);
    int m_wrapped = wrap_index(m_prime, _M);

    float phase = _RealMap.Load(int3(n_wrapped, m_wrapped, 0)).g;
    int n_conj_wrapped = wrap_index(-n_prime, _N);
    int m_conj_wrapped = wrap_index(-m_prime, _M);
    float2 basis = basis_dft(n_wrapped, m_wrapped);
    float2 basis_conjugate = complex_conjugate(basis_dft(n_conj_wrapped, m_conj_wrapped));
    float2 exp1 = complex_exp(omega(n_wrapped, m_wrapped) * time + phase * _PhaseMult);
    float2 exp2 = complex_conjugate(exp1);
    return complex_add(complex_mult(basis, exp1), complex_mult(basis_conjugate, exp2));
}

// ---- Main Function -----
[numthreads(8,1,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Calculate DFT here, store in texture
    Result[id.xz] = float4(dft(id.x, id.z, _Time.x), 0.0, 1.0);
}
